---
title: 并查集——关押罪犯
date: 2019-9-24
categories: "湖中镜岛"
tags: ["数据结构"]
---

相当不错的帮助我们熟悉并查集的习题。简单，但不会（蔡）。

## 一、题目
&#8194;&#8194;&#8194;&#8194;S城现有两座监狱，一共关押着N名罪犯，编号分别为1-N。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为c 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为c的冲突事件。
&#8194;&#8194;&#8194;&#8194;每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到S城Z市长那里。公务繁忙的Z市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。
&#8194;&#8194;&#8194;&#8194;在详细考察了N名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。
&#8194;&#8194;&#8194;&#8194;那么，应如何分配罪犯，才能使Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？

**输入格式**
&#8194;&#8194;&#8194;&#8194;每行中两个数之间用一个空格隔开。第一行为两个正整数N、M。N、M分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的M行每行为三个正整数a、b、c，表示a号和b号囚犯之间仇恨值为c。
&#8194;&#8194;&#8194;&#8194;数据保证 $1<a\leq b\leq N, 0<c\leq1,000,000,000$ ，且每对罪犯组合只出现一次。

**输出格式**
&#8194;&#8194;&#8194;&#8194;共1行，为Z市长看到的那个冲突事件的影响力，如果本年内监狱中未发生任何冲突事件，请输出0。

## 二、思路
&#8194;&#8194;&#8194;&#8194;首先考虑将所有权值从大到小排序，然后从头遍历，尽量将两个点分为两组，当发现两个点同处于一组的时候无法再分就输出这个值，这个值就我们能找到无法再分的最小值，此时，我们需要一个将点分组的算法。

**为什么想到使用并查集？**
&#8194;&#8194;&#8194;&#8194;该题属于较为明显的图类题目，其实质是将一张无向联通图分为两组，使得组内点之间的权值尽量小。在仅有点与点之间关系的情况下，考虑令不同点形成一个集合，并查集或者染色法是我们经常使用的。此处略过二分染色法的解法，看看如何使用并查集表示。

**使用朴素并查集能不能行？**
&#8194;&#8194;&#8194;&#8194;由于我们得到的数据只能判断两个点不在一组，而不能判断两个点在一组（对于遍历到的每条边，试图将两边的点分为两组），因此我们无法采用相同并查集为一组的做法。那么试试处于相同集合内的点必无法分为同一组能不能行？答案是也不能行，因为当两个点之间的联系为奇数时，如：我们遍历到的前三条边分别是：1-2，3-4，1-3时，2和4已经被分到一个集合，他们之间的联系为2-1-3-4，这表示24不能被分到同一组。如果下一条边是24，在这个算法中循环就终止了，但实际上将14分为一组，23分为另一组是完全可以满足上面四条边的要求的。此处就出现了谬误。

**所以应该怎么做？**
&#8194;&#8194;&#8194;&#8194;最终我们维护两个并查集，第一个并查集即处于相同集合中的点会被分为一组（分到一个监狱），另一个并查集维护分到同一集合中的点绝不会被分为一组。这样就能避免上面的问题。其思路是先遍历，如果遍历到的点尚未遍历过，就把这个点的敌人放到第二个并查集中。如果遍历到的点已经遍历过了（那么就说明该点至少有一个敌人），我们根据第二个并查集将该点旧的敌人和新的敌人放到同一集合中，具体表现在第一个并查集中两个敌人取一个值。

## 三、Java实现
```java
import java.util.*;

public class Imprisonment{
    static int[] ufSet;
    static int[] enemy;

    //寻找并查集根节点
    public static int findFather(int x){
        if(ufSet[x] == x){
            return x;
        }
        ufSet[x] = findFather(ufSet[x]);
        return ufSet[x];
    }

    //将两个并查集统合成一个
    public static void union(int x, int y){
        int fx = findFather(x);
        int fy = findFather(y);
        if(fx != fy){
            ufSet[fx] = fy;
        }
    }


    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int M = sc.nextInt();
        int[][] value = new int[M][3];
        ufSet = new int[N+1];
        enemy = new int[N+1];

        for(int i=0; i<M; i++){
            for(int j=0; j<3; j++){
                value[i][j] = sc.nextInt();
            }
        }
        
        for(int i=0; i<N+1; i++){
            ufSet[i] = i;
        }

        //排序
        Arrays.sort(value, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2){
                return o2[2]-o1[2];
            }
        });

        for(int i=0; i<M; i++){
            int x = value[i][0];
            int y = value[i][1];

            int fx = findFather(x);
            int fy = findFather(y);
            //如果在第一个并查集中二者父节点相同，即处于一个集合中
            if(fx == fy){
                //说明这两个点不可再分，直接输出
                System.out.println(value[i][2]);
                return;
            }

            //放置敌人到第二个并查集中
            if(enemy[x] == 0){
                enemy[x] = y;
            }else{
                //统合旧敌人和新敌人
                union(enemy[x], y);
            }

            if(enemy[y] == 0){
                enemy[y] = x;
            }else{
                union(enemy[y],x);
            }
            
        }
        System.out.println(0);
    }
}
```
